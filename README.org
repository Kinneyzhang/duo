
#+STARTUP: showall

* Table of contents                                                     :TOC_2_gh:
- [[#introduction][Introduction]]
  - [[#keep-it-simple][Keep It Simple]]
- [[#summary-of-available-functions][Summary of available functions]]
- [[#technical-details][Technical details]]
  - [[#circular-lists][Circular lists]]
  - [[#next--previous-vs-after--before][Next / Previous vs After / Before]]
  - [[#remove-vs-delete][Remove vs Delete]]
  - [[#returned-objects][Returned objects]]
  - [[#assoc][Assoc]]

* Introduction

Duo is a library of in place list operations in Emacs-Lisp. Its functions modify the
original list when :

  - It’s easy to get back : rotate, reverse, move, etc

  - The name is clear : push, pop, add, drop, insert, remove, etc

    + When an element is removed, a reference to it is often returned

However, when it’s difficult or impossible to reverse the operation, a
new list is created, with the values of the original one. For
instance :

  - filter

  - partition

If in doubt, check their doc.

In fact, the functions use and return references whenever possible.
It’s implemented with =(CAR . CDR)= =cons=, which are called =duo=,
hence the name of the library. These cons are everywhere in Elisp,
either explicitely created or as brick components in lists. A list
variable =list= is itself the cons at the beginning of the list.
=(cdr list)= is the second cons in the list. And so one with
=(cddr list)=, =(nthcdr N list)=. Generally speaking, a member
of a list is a cons =(value . next-member-in-list)=. Most of Elisp
is built around these =(CAR . CDR)= double pointers. You can even
construct binary trees with it.

When a =duo= has to be modified, it’s generally by =setcar= and
=setcdr= built-in.


** Keep It Simple

Primarily use Elisp C source code :

  - Built-ins :

    + car

    + cdr

    + nthcdr

    + setcar

    + setcdr

    + etc

  - Special forms :

    + if

    + cond

    + while

    + etc


* Summary of available functions

  - Finding cons in list

  - Finding previous / next cons

    + In plain list

    + In virtual circular list

  - Change element

  - Push, Add

    + Anytime

    + Only if new element

  - Pop, Drop

  - Truncate

  - Rotate <- or ->

  - Roll until a cons is first or last

  - Reverse

  - Insert

  - Remove, Delete

    + One occurence

    + All occurence of a value

  - Teleport : move after or before another cons or element

  - Move previous or next

    + In plain list

    + In virtual circular list

  - Exchange cons or elements

  - Insert at group beginning or end

  - Filter

    + Next / Previous in same filter

  - Partition with a key function


* Technical details


** Circular lists

Caution : applying some of these functions to circular lists would
produce infinite loops.

However, some functions, like =*-circ-*= or =*-rotate-*=, simulate
virtual circular lists by :

  - Continuing at the beginning once arrived at the end

  - Continuing at the end once arrived at the beginning


** Next / Previous vs After / Before

There is a slight difference between next/previous and after/before
functions :

  - Next / Previous use a cons as main argument

  - After / Before use the value of an element of the list as main argument


** Remove vs Delete

There is a slight difference between remove and delete functions :

  - Remove removes a cons given as argument

  - Delete remove the first cons whose car matches an element given as argument


** Returned objects

When you pass a list as argument of a function, the calling scope
=list-var= holds the address of the first cons of the list. The
argument =arg-list-var= holds a copy of it. Using ~(setq list ...)~
inside the definition of the function changes the argument list
reference, not the calling scope one. So, the calling scope address is
not updated. As a result, you need either :

  - to recover the modified list as the returned value of the function

    + ~(setq list (function list ...))~

  - to pass a reference to the list as argument (=*-ref-*= functions)

    + ~(setq reflist (cons list nil)) (function reflist ...)~

A common case of this situation is with functions which modify the
first cons of the list : push, pop, etc.

Check their doc to know how to recover the updated list.


** Assoc

The classic =assoc= function return the cons =(key . value)=, which is
the /content/ of the Alist element, whereas the =duo-assoc= function
return the duo =((key . value) . next-member-in-alist)=, real member of
the Alist.
